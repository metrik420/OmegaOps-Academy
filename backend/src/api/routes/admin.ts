/**
 * FILE: src/api/routes/admin.ts
 * PURPOSE: Admin-protected routes for content moderation and management.
 *          Requires HTTP Basic Auth for access.
 * INPUTS: Authenticated admin credentials, update IDs
 * OUTPUTS: JSON responses for admin operations
 * NOTES:
 *   - All routes require authentication via basicAuthMiddleware
 *   - Provides approve/reject workflow for pending updates
 *   - Creates audit trail via changelog
 *   - Critical for maintaining content quality
 */

import { Router, Request, Response } from 'express';
import { asyncHandler, Errors } from '../middleware/errorHandler';
import { requireAdmin, getAdminUser } from '../middleware/auth';
import {
  getDatabase,
  parseJsonField,
  getCurrentTimestamp,
  stringifyForDb,
} from '../../database/db';
import { logger } from '../../utils/logger';
import { validate, updateIdParamSchema, rejectUpdateSchema } from '../../utils/validation';
import { PendingUpdate, ApiResponse } from '../../types';
import { v4 as uuidv4 } from 'uuid';

const router = Router();

/*
 * Apply authentication middleware to all admin routes.
 * Every request to /api/admin/* must pass basic auth.
 */
router.use(requireAdmin);

/**
 * POST /api/admin/pending-updates/:id/approve
 *
 * Approves a pending update and applies the proposed changes.
 * This is the core of the content moderation workflow.
 *
 * Path parameters:
 * - id: Pending update UUID
 *
 * WORKFLOW:
 * 1. Validate update exists and is pending
 * 2. Apply proposed changes to target entity
 * 3. Update pending_update status to 'approved'
 * 4. Create changelog entry for audit trail
 * 5. Return success with applied changes
 *
 * SECURITY CONSIDERATIONS:
 * - Only authenticated admins can approve
 * - Changes are logged with admin username
 * - Proposed content was generated by trusted workers
 * - Still validate before applying (defense in depth)
 *
 * IMPORTANT:
 * This operation modifies production content.
 * Review carefully before approving.
 */
router.post(
  '/pending-updates/:id/approve',
  asyncHandler(async (req: Request, res: Response) => {
    // Validate path parameter
    const validation = validate(updateIdParamSchema, req.params);
    if (!validation.success) {
      throw Errors.badRequest(`Invalid update ID: ${validation.errors.join(', ')}`);
    }

    const { id } = validation.data;
    const adminUser = getAdminUser(req);
    const db = getDatabase();
    const now = getCurrentTimestamp();

    /*
     * Fetch the pending update.
     * Must exist and be in 'pending' status.
     */
    const updateStmt = db.prepare('SELECT * FROM pending_updates WHERE id = ?');
    const updateRow = updateStmt.get(id) as Record<string, unknown> | undefined;

    if (!updateRow) {
      throw Errors.notFound('Pending update');
    }

    const pendingUpdate: PendingUpdate = {
      id: updateRow['id'] as string,
      type: updateRow['type'] as PendingUpdate['type'],
      entityId: updateRow['entityId'] as string,
      changesSummary: updateRow['changesSummary'] as string,
      proposedContent: parseJsonField(updateRow['proposedContent'], {}),
      status: updateRow['status'] as PendingUpdate['status'],
      proposedBy: updateRow['proposedBy'] as string,
      reviewedBy: (updateRow['reviewedBy'] as string | null) ?? undefined,
      reviewedAt: (updateRow['reviewedAt'] as string | null) ?? undefined,
      appliedAt: (updateRow['appliedAt'] as string | null) ?? undefined,
      createdAt: updateRow['createdAt'] as string,
      updatedAt: updateRow['updatedAt'] as string,
    };

    // Check if already processed
    if (pendingUpdate.status !== 'pending') {
      throw Errors.conflict(
        `Update has already been ${pendingUpdate.status}. Cannot approve again.`
      );
    }

    /*
     * Apply the proposed changes to the target entity.
     * This is where the actual content modification happens.
     *
     * STRATEGY:
     * - For new entities: INSERT into appropriate table
     * - For updates: UPDATE specific fields
     * - For deletions: Soft delete (set status = 'deprecated')
     *
     * NOTE: This is a simplified implementation for MVP.
     * Production would need more sophisticated merging logic.
     */
    const proposedContent = pendingUpdate.proposedContent as Record<string, unknown>;

    switch (pendingUpdate.type) {
      case 'software': {
        /*
         * Software tool update/creation.
         * If entityId is 'new', INSERT. Otherwise, UPDATE.
         */
        if (pendingUpdate.entityId === 'new') {
          // New tool discovery
          const toolId = proposedContent['id'] as string || uuidv4();
          const insertStmt = db.prepare(`
            INSERT INTO software_tools (
              id, name, category, description, useCases, difficulty,
              supportedEnvironments, installGuides, configGuides, status,
              relevanceScore, firstSeenAt, lastUpdatedAt, lastVerifiedAt,
              sources, confidenceLevel
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          `);

          insertStmt.run(
            toolId,
            proposedContent['name'] || 'Unknown Tool',
            proposedContent['category'] || 'Uncategorized',
            proposedContent['description'] || '',
            stringifyForDb(proposedContent['useCases'] || []),
            proposedContent['difficulty'] || 'intermediate',
            stringifyForDb(proposedContent['supportedEnvironments'] || []),
            stringifyForDb(proposedContent['installGuides'] || []),
            stringifyForDb(proposedContent['configGuides'] || []),
            'approved', // Auto-approve since admin is approving
            proposedContent['relevanceScore'] || 50,
            now,
            now,
            now,
            stringifyForDb(proposedContent['sources'] || []),
            proposedContent['confidenceLevel'] || 'medium'
          );

          logger.info('New software tool created via approval', {
            toolId,
            name: proposedContent['name'],
          });
        } else {
          /*
           * Update existing tool.
           * Only update fields that are in proposedContent.
           * This allows partial updates.
           */
          const updateFields: string[] = [];
          const updateValues: unknown[] = [];

          // Build dynamic UPDATE statement
          const allowedFields = [
            'name',
            'category',
            'description',
            'difficulty',
            'status',
            'relevanceScore',
            'confidenceLevel',
          ];

          for (const field of allowedFields) {
            if (field in proposedContent) {
              updateFields.push(`${field} = ?`);
              updateValues.push(proposedContent[field]);
            }
          }

          // JSON fields need stringification
          const jsonFields = [
            'useCases',
            'supportedEnvironments',
            'installGuides',
            'configGuides',
            'sources',
          ];

          for (const field of jsonFields) {
            if (field in proposedContent) {
              updateFields.push(`${field} = ?`);
              updateValues.push(stringifyForDb(proposedContent[field]));
            }
          }

          // Always update lastUpdatedAt and lastVerifiedAt
          updateFields.push('lastUpdatedAt = ?', 'lastVerifiedAt = ?');
          updateValues.push(now, now);

          if (updateFields.length > 0) {
            const sql = `UPDATE software_tools SET ${updateFields.join(', ')} WHERE id = ?`;
            updateValues.push(pendingUpdate.entityId);

            const toolUpdateStmt = db.prepare(sql);
            toolUpdateStmt.run(...updateValues);

            logger.info('Software tool updated via approval', {
              toolId: pendingUpdate.entityId,
            });
          }
        }
        break;
      }

      case 'knowledge': {
        /*
         * Knowledge topic update.
         * Similar pattern to software tools.
         */
        if (pendingUpdate.entityId === 'new') {
          const topicId = proposedContent['id'] as string || uuidv4();
          const insertStmt = db.prepare(`
            INSERT INTO knowledge_topics (
              id, title, description, category, content, relatedMissions,
              relatedLabs, sources, confidenceLevel, lastVerifiedAt,
              createdAt, updatedAt
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          `);

          insertStmt.run(
            topicId,
            proposedContent['title'] || 'Untitled Topic',
            proposedContent['description'] || '',
            proposedContent['category'] || 'General',
            proposedContent['content'] || '',
            stringifyForDb(proposedContent['relatedMissions'] || []),
            stringifyForDb(proposedContent['relatedLabs'] || []),
            stringifyForDb(proposedContent['sources'] || []),
            proposedContent['confidenceLevel'] || 'medium',
            now,
            now,
            now
          );

          logger.info('New knowledge topic created via approval', { topicId });
        } else {
          // Update existing topic
          const updateStmt = db.prepare(`
            UPDATE knowledge_topics
            SET
              content = COALESCE(?, content),
              sources = COALESCE(?, sources),
              lastVerifiedAt = ?,
              updatedAt = ?
            WHERE id = ?
          `);

          updateStmt.run(
            proposedContent['content'] as string | null,
            proposedContent['sources'] ? stringifyForDb(proposedContent['sources']) : null,
            now,
            now,
            pendingUpdate.entityId
          );

          logger.info('Knowledge topic updated via approval', {
            topicId: pendingUpdate.entityId,
          });
        }
        break;
      }

      case 'mission':
      case 'lab':
      case 'config': {
        /*
         * For MVP, these are logged but not automatically applied.
         * Missions and labs are core curriculum and need careful review.
         * Config changes may need manual application.
         */
        logger.info(`${pendingUpdate.type} update approved but requires manual application`, {
          type: pendingUpdate.type,
          entityId: pendingUpdate.entityId,
          changesSummary: pendingUpdate.changesSummary,
        });
        break;
      }
    }

    /*
     * Update the pending_update record to reflect approval.
     */
    const approveStmt = db.prepare(`
      UPDATE pending_updates
      SET
        status = 'approved',
        reviewedBy = ?,
        reviewedAt = ?,
        appliedAt = ?,
        updatedAt = ?
      WHERE id = ?
    `);

    approveStmt.run(adminUser.username, now, now, now, id);

    /*
     * Create changelog entry for audit trail.
     * This provides transparency and accountability.
     */
    const changelogId = uuidv4();
    const changelogStmt = db.prepare(`
      INSERT INTO changelog (
        id, entryType, affectedEntities, summary, appliedAt, createdAt
      ) VALUES (?, ?, ?, ?, ?, ?)
    `);

    changelogStmt.run(
      changelogId,
      pendingUpdate.entityId === 'new' ? 'new_tool' : 'update',
      stringifyForDb([pendingUpdate.entityId]),
      `${pendingUpdate.changesSummary} (Approved by ${adminUser.username})`,
      now,
      now
    );

    logger.info('Pending update approved', {
      updateId: id,
      type: pendingUpdate.type,
      entityId: pendingUpdate.entityId,
      approvedBy: adminUser.username,
      changelogId,
    });

    const response: ApiResponse<{
      updateId: string;
      status: string;
      appliedAt: string;
      approvedBy: string;
      changelogId: string;
    }> = {
      success: true,
      data: {
        updateId: id,
        status: 'approved',
        appliedAt: now,
        approvedBy: adminUser.username,
        changelogId,
      },
    };

    res.json(response);
  })
);

/**
 * POST /api/admin/pending-updates/:id/reject
 *
 * Rejects a pending update without applying changes.
 * Records rejection for audit purposes.
 *
 * Path parameters:
 * - id: Pending update UUID
 *
 * Request body (optional):
 * - reason: Why the update was rejected
 *
 * WORKFLOW:
 * 1. Validate update exists and is pending
 * 2. Update status to 'rejected'
 * 3. Record rejection reason and reviewer
 * 4. No changelog entry (nothing was changed)
 *
 * USE CASES:
 * - Inaccurate information in proposed update
 * - Inappropriate content
 * - Duplicate of existing content
 * - Low quality or incomplete update
 */
router.post(
  '/pending-updates/:id/reject',
  asyncHandler(async (req: Request, res: Response) => {
    // Validate path parameter
    const paramValidation = validate(updateIdParamSchema, req.params);
    if (!paramValidation.success) {
      throw Errors.badRequest(`Invalid update ID: ${paramValidation.errors.join(', ')}`);
    }

    // Validate request body
    const bodyValidation = validate(rejectUpdateSchema, req.body);
    if (!bodyValidation.success) {
      throw Errors.badRequest(`Invalid request body: ${bodyValidation.errors.join(', ')}`);
    }

    const { id } = paramValidation.data;
    const { reason } = bodyValidation.data;
    const adminUser = getAdminUser(req);
    const db = getDatabase();
    const now = getCurrentTimestamp();

    // Fetch the pending update
    const updateStmt = db.prepare('SELECT * FROM pending_updates WHERE id = ?');
    const updateRow = updateStmt.get(id) as Record<string, unknown> | undefined;

    if (!updateRow) {
      throw Errors.notFound('Pending update');
    }

    const currentStatus = updateRow['status'] as string;

    // Check if already processed
    if (currentStatus !== 'pending') {
      throw Errors.conflict(
        `Update has already been ${currentStatus}. Cannot reject again.`
      );
    }

    /*
     * Update status to rejected.
     * Store reason in changesSummary (appended) for record.
     */
    const existingSummary = updateRow['changesSummary'] as string;
    const updatedSummary = reason
      ? `${existingSummary} | REJECTED: ${reason}`
      : existingSummary;

    const rejectStmt = db.prepare(`
      UPDATE pending_updates
      SET
        status = 'rejected',
        changesSummary = ?,
        reviewedBy = ?,
        reviewedAt = ?,
        updatedAt = ?
      WHERE id = ?
    `);

    rejectStmt.run(updatedSummary, adminUser.username, now, now, id);

    logger.info('Pending update rejected', {
      updateId: id,
      type: updateRow['type'],
      entityId: updateRow['entityId'],
      rejectedBy: adminUser.username,
      reason,
    });

    const responseData: {
      updateId: string;
      status: string;
      rejectedAt: string;
      rejectedBy: string;
      reason?: string;
    } = {
      updateId: id,
      status: 'rejected',
      rejectedAt: now,
      rejectedBy: adminUser.username,
    };

    if (reason !== undefined) {
      responseData.reason = reason;
    }

    const response: ApiResponse<typeof responseData> = {
      success: true,
      data: responseData,
    };

    res.json(response);
  })
);

/**
 * GET /api/admin/dashboard
 *
 * Returns admin dashboard statistics.
 * Overview of system health and pending work.
 *
 * METRICS:
 * - Pending updates count (needs attention)
 * - Content counts (missions, labs, tools, topics)
 * - Recent activity
 * - System health indicators
 */
router.get(
  '/dashboard',
  asyncHandler(async (req: Request, res: Response) => {
    const adminUser = getAdminUser(req);
    const db = getDatabase();

    // Count pending updates
    const pendingStmt = db.prepare(
      "SELECT COUNT(*) as count FROM pending_updates WHERE status = 'pending'"
    );
    const pendingCount = (pendingStmt.get() as { count: number }).count;

    // Count content entities
    const missionsCount = (
      db.prepare('SELECT COUNT(*) as count FROM missions').get() as { count: number }
    ).count;

    const labsCount = (
      db.prepare('SELECT COUNT(*) as count FROM labs').get() as { count: number }
    ).count;

    const toolsCount = (
      db
        .prepare("SELECT COUNT(*) as count FROM software_tools WHERE status IN ('approved', 'seeded')")
        .get() as { count: number }
    ).count;

    const topicsCount = (
      db.prepare('SELECT COUNT(*) as count FROM knowledge_topics').get() as { count: number }
    ).count;

    // Recent changelog entries
    const recentChangesStmt = db.prepare(`
      SELECT * FROM changelog
      ORDER BY appliedAt DESC
      LIMIT 5
    `);
    const recentChanges = recentChangesStmt.all() as Array<Record<string, unknown>>;

    const dashboard = {
      admin: adminUser.username,
      pendingReviewCount: pendingCount,
      contentCounts: {
        missions: missionsCount,
        labs: labsCount,
        softwareTools: toolsCount,
        knowledgeTopics: topicsCount,
      },
      recentChanges: recentChanges.map((row) => ({
        id: row['id'],
        entryType: row['entryType'],
        summary: row['summary'],
        appliedAt: row['appliedAt'],
      })),
      timestamp: new Date().toISOString(),
    };

    const response: ApiResponse<typeof dashboard> = {
      success: true,
      data: dashboard,
    };

    logger.debug('Admin dashboard accessed', { admin: adminUser.username });

    res.json(response);
  })
);

export default router;
